#ifndef NORMAL_SHADER_H
#define NORMAL_SHADER_H

std::string normalVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"out vec4 rawVert;                                   \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    rawVert  = gl_Vertex;                    \n"
"}                                                   \n";

std::string normalFloatVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in float value;                \n"
"uniform float min;                                  \n"
"uniform float max;                                  \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"    gl_TexCoord[1].x = clamp((value - min) / (max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string normalVecVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in vec3 value;                \n"
"uniform float min;                                  \n"
"uniform float max;                                  \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"    gl_TexCoord[1].x = clamp((length(value) - min) / (max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string normalIntVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in int value;                \n"
"uniform int min;                                  \n"
"uniform int max;                                  \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"    //if(value == -1)                                 \n"
"      //  gl_TexCoord[1].x = 0.0;                     \n"
"    //else                                            \n"
"      //  gl_TexCoord[1].x = 1.0;                     \n"
"    gl_TexCoord[1].x = clamp(float(value - min) / float(max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string normalGeomSrc =
"#version 120                                        \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"varying in vec3 ls[3];                              \n"
"varying in vec4 rawVert[3];                         \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n" 
"    vec3 normal = normalize(cross(rawVert[1].xyz - rawVert[0].xyz, rawVert[2].xyz - rawVert[0].xyz)); \n"
"    vec3 n1 = normalize(gl_NormalMatrix * normal);  \n"
"    vec3 n2 = normalize(gl_NormalMatrix * -normal); \n"
"    for(int i = 0; i < gl_VerticesIn; ++i)          \n"
"    {                                               \n"
"        float diffuse = max(0.0, dot(ls[i], n1));   \n"
"        float diffuse2 = max(0.0, dot(ls[i], n2));  \n"
"        gl_FrontColor = gl_FrontColorIn[i] * clamp(diffuse+diffuse2, 0.0, 1.0); \n"
"        gl_Position = gl_PositionIn[i];             \n"
"        EmitVertex();                               \n"
"    }                                               \n"
"}                                                   \n";

std::string normalFloatGeomSrc =
"#version 120                                        \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"varying in vec3 ls[3];                              \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n" 
"    vec3 normal = normalize(cross(gl_TexCoordIn[1][0].xyz - gl_TexCoordIn[0][0].xyz, gl_TexCoordIn[2][0].xyz - gl_TexCoordIn[0][0].xyz)); \n"
"    vec3 n1 = normalize(gl_NormalMatrix * normal);  \n"
"    vec3 n2 = normalize(gl_NormalMatrix * -normal); \n"
"    for(int i = 0; i < gl_VerticesIn; ++i)          \n"
"    {                                               \n"
"        float diffuse = max(0.0, dot(ls[i], n1));   \n"
"        float diffuse2 = max(0.0, dot(ls[i], n2));  \n"
"        gl_FrontColor = gl_FrontColorIn[i];         \n"
"        gl_TexCoord[0].y = clamp(diffuse+diffuse2, 0.0, 1.0); \n"
"        gl_Position = gl_PositionIn[i];             \n"
"        gl_TexCoord[0].x = gl_TexCoordIn[i][1].x;    \n"
"        EmitVertex();                               \n"
"    }                                               \n"
"}                                                   \n";

std::string normalFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    gl_FragColor = gl_Color;                        \n"
"}                                                   \n";

std::string normalFloatFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"uniform sampler1D tex;                              \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    gl_FragColor = texture1D(tex,gl_TexCoord[0].x) * gl_TexCoord[0].y; \n"
"    //gl_FragColor = gl_Color * gl_TexCoord[0].x * gl_TexCoord[0].y; \n"
"    //gl_FragColor = gl_Color * gl_TexCoord[0].x;            \n"
"    //gl_FragColor = texture1D(tex,0.1) * gl_TexCoord[0].y; \n"
"}                                                   \n";


std::string isoFloatVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in float value;                \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = gl_Vertex;                     \n"
"                                                    \n"
"    gl_TexCoord[0].x = value; \n"
"}                                                   \n";

std::string isoVecVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in vec3 value;                \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = gl_Vertex;                     \n"
"                                                    \n"
"    gl_TexCoord[0].x = length(value); \n"
"}                                                   \n";

std::string isoGeomSrc =
"#version 150 compatibility                          \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"in vec3 ls[4];                                      \n"
"                                                    \n"
"flat out vec3 norm;                                 \n"
"out vec3 lp;                                        \n"
"                                                    \n"
"uniform float isoMax;                               \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    int order[4];                                   \n"
"    int count = 0;                                  \n"
"    int back = 3;                                   \n"
"                                                    \n"
"    for(int i = 0; i < 4; ++i)                      \n"
"    {                                               \n"
"        if(gl_TexCoordIn[i][0].x <= isoMax)         \n"
"        {                                           \n"
"            order[count] = i;                       \n"
"            count++;                                \n"
"        }                                           \n"
"        else                                        \n"
"        {                                           \n"
"            order[back] = i;                        \n"
"            back--;                                 \n"
"        }                                           \n"
"    }                                               \n"
"                                                    \n"
"    if(count == 0 || count == 4)                    \n"
"    {                                               \n"
"        return;                                     \n"
"    }                                               \n"
"                                                    \n"
"    int tcount = count;                             \n"
"                                                    \n"
"    float ratio = (isoMax - gl_TexCoordIn[order[count]][0].x) / (gl_TexCoordIn[order[back]][0].x - gl_TexCoordIn[order[count]][0].x); \n"
"                                                    \n"
"    vec4 points[3];                                 \n"
"    lp = mix(ls[order[count]],ls[order[back]],ratio); \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    points[0] = mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio);                        \n"
"    gl_Position = gl_ModelViewProjectionMatrix * points[0]; \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount == 3)                                 \n"
"    {                                               \n"
"        back--;                                     \n"
"    }                                               \n"
"    else                                            \n"
"    {                                               \n"
"        count++;                                    \n"
"    }                                               \n"
"                                                    \n"
"    ratio = (isoMax - gl_TexCoordIn[order[count]][0].x) / (gl_TexCoordIn[order[back]][0].x - gl_TexCoordIn[order[count]][0].x); \n"
"                                                    \n"
"    lp = mix(ls[order[count]],ls[order[back]],ratio); \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    points[1] = mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_Position = gl_ModelViewProjectionMatrix * points[1]; \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount == 3)                                 \n"
"    {                                               \n"
"        back--;                                     \n"
"    }                                               \n"
"    else if(tcount == 2)                            \n"
"    {                                               \n"
"        count--;                                    \n"
"        back--;                                     \n"
"    }                                               \n"
"    else                                            \n"
"    {                                               \n"
"        count++;                                    \n"
"    }                                               \n"
"                                                    \n"
"    ratio = (isoMax - gl_TexCoordIn[order[count]][0].x) / (gl_TexCoordIn[order[back]][0].x - gl_TexCoordIn[order[count]][0].x); \n"
"                                                    \n"
"    lp = mix(ls[order[count]],ls[order[back]],ratio); \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    points[2] = mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_Position = gl_ModelViewProjectionMatrix * points[2]; \n"
"    norm = normalize(gl_NormalMatrix * normalize(cross(points[1].xyz - points[0].xyz, points[2].xyz - points[0].xyz))); \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount != 2)                                 \n"
"    {                                               \n"
"        return;                                     \n"
"    }                                               \n"
"                                                    \n"
"    count++;                                        \n"
"                                                    \n"
"    ratio = (isoMax - gl_TexCoordIn[order[count]][0].x) / (gl_TexCoordIn[order[back]][0].x - gl_TexCoordIn[order[count]][0].x); \n"
"                                                    \n"
"    lp = mix(ls[order[count]],ls[order[back]],ratio); \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    points[0] = mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_Position = gl_ModelViewProjectionMatrix * points[0]; \n"
"    norm = normalize(gl_NormalMatrix * normalize(cross(points[1].xyz - points[0].xyz, points[2].xyz - points[0].xyz))); \n"
"    EmitVertex();                                   \n"
"}                                                   \n";

std::string isoFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"flat in vec3 norm;                                  \n"
"in vec3 lp;                                         \n"
"                                                    \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    float diffuse = max(0.0, dot(lp, norm));        \n"
"    float diffuse2 = max(0.0, dot(lp, -norm));      \n"   
"    gl_FragColor = gl_Color * clamp(diffuse+diffuse2, 0.0, 1.0);                        \n"
"}                                                   \n";

std::string planeFloatVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in float value;                \n"
"                                                    \n"
"uniform float min;                                  \n"
"uniform float max;                                  \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"    gl_Position = gl_Vertex;                        \n"
"    gl_TexCoord[0].x = clamp((value - min) / (max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string planeVecVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in vec3 value;                \n"
"                                                    \n"
"uniform float min;                                  \n"
"uniform float max;                                  \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"    gl_Position = gl_Vertex;                        \n"
"    gl_TexCoord[0].x = clamp((length(value) - min) / (max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string planeGeomSrc =
"#version 150 compatibility                          \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"uniform vec3 planePoint;                            \n"
"uniform vec3 planeNormal;                           \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    int order[4];                                   \n"
"    int count = 0;                                  \n"
"    int back = 3;                                   \n"
"                                                    \n"
"    float dist[4];                                  \n"
"    for(int i = 0; i < 4; ++i)                      \n"
"    {                                               \n"
"        dist[i] = dot(gl_PositionIn[i].xyz-planePoint,planeNormal); \n"
"        if(dist[i] > 0.0)         \n"
"        {                                           \n"
"            order[count] = i;                       \n"
"            count++;                                \n"
"        }                                           \n"
"        else                                        \n"
"        {                                           \n"
"            order[back] = i;                        \n"
"            back--;                                 \n"
"        }                                           \n"
"    }                                               \n"
"                                                    \n"
"    if(count == 0 || count == 4)                    \n"
"    {                                               \n"
"        return;                                     \n"
"    }                                               \n"
"                                                    \n"
"    int tcount = count;                             \n"
"                                                    \n"
"    float ratio = abs(dist[order[count]]) / (abs(dist[order[back]]) + abs(dist[order[count]])); \n"
"                                                    \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    gl_Position = gl_ModelViewProjectionMatrix * mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_TexCoord[0].x = mix(gl_TexCoordIn[order[count]][0].x,gl_TexCoordIn[order[back]][0].x,ratio); \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount == 3)                                 \n"
"    {                                               \n"
"        back--;                                     \n"
"    }                                               \n"
"    else                                            \n"
"    {                                               \n"
"        count++;                                    \n"
"    }                                               \n"
"                                                    \n"
"    ratio = abs(dist[order[count]]) / (abs(dist[order[back]]) + abs(dist[order[count]])); \n"
"                                                    \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    gl_Position = gl_ModelViewProjectionMatrix * mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_TexCoord[0].x = mix(gl_TexCoordIn[order[count]][0].x,gl_TexCoordIn[order[back]][0].x,ratio); \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount == 3)                                 \n"
"    {                                               \n"
"        back--;                                     \n"
"    }                                               \n"
"    else if(tcount == 2)                            \n"
"    {                                               \n"
"        count--;                                    \n"
"        back--;                                     \n"
"    }                                               \n"
"    else                                            \n"
"    {                                               \n"
"        count++;                                    \n"
"    }                                               \n"
"                                                    \n"
"    ratio = abs(dist[order[count]]) / (abs(dist[order[back]]) + abs(dist[order[count]])); \n"
"                                                    \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]];  \n"
"    gl_Position = gl_ModelViewProjectionMatrix * mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_TexCoord[0].x = mix(gl_TexCoordIn[order[count]][0].x,gl_TexCoordIn[order[back]][0].x,ratio); \n"
"    EmitVertex();                                   \n"
"                                                    \n"
"    if(tcount != 2)                                 \n"
"    {                                               \n"
"        return;                                     \n"
"    }                                               \n"
"                                                    \n"
"    count++;                                        \n"
"                                                    \n"
"    ratio = abs(dist[order[count]]) / (abs(dist[order[back]]) + abs(dist[order[count]])); \n"
"                                                    \n"
"    gl_FrontColor = gl_FrontColorIn[order[count]]; \n"
"    gl_Position = gl_ModelViewProjectionMatrix * mix(gl_PositionIn[order[count]],gl_PositionIn[order[back]],ratio); \n"
"    gl_TexCoord[0].x = mix(gl_TexCoordIn[order[count]][0].x,gl_TexCoordIn[order[back]][0].x,ratio); \n"
"    EmitVertex();                                   \n"
"}                                                   \n";

std::string planeFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"uniform sampler1D tex;                              \n"
"uniform float alpha;                                \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    gl_FragColor = texture1D(tex,gl_TexCoord[0].x); \n"
"    //gl_FragColor = gl_Color * gl_TexCoord[0].x * gl_TexCoord[0].y; \n"
"    //gl_FragColor.rgb = vec3(gl_TexCoord[0].x,gl_TexCoord[0].x,gl_TexCoord[0].x);            \n"
"    gl_FragColor.a = alpha;                           \n"
"}                                                   \n";

#endif
